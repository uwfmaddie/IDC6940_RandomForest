---
title: "Random Forest in the Health Industry"
subtitle: "An analysis of the random forest algorithm and its applications in the health industry"
author: "Maddie Sortino and Jisa Jose (Advisor: Dr. Cohen)"
date: '`r Sys.Date()`'
format:
  html:
    code-fold: true
course: Capstone Projects in Data Science
bibliography: references.bib # file contains bibtex for references
always_allow_html: true # this allows to get PDF with HTML features
self-contained: true
execute: 
  warning: false
  message: false
editor: 
  markdown: 
    wrap: 72
---

Slides: [slides.html](slides.html){target="_blank"} ( Go to `slides.qmd`
to edit)

Literature Review: [litreview.html](litreview.html)

## Introduction

Machine learning has significantly advanced predictive analytics,
particularly in the medical industry and clinical decision-making. Among
the many available algorithms, Random Forest (RF) has emerged as a
powerful tool due to its ability to handle high-dimensional data,
resistance to overfitting, and high accuracy in predicting medical
events [@rigatti2017random]. RF is an ensemble learning method composed
of multiple decision trees, which are generated through bagging and
random feature selection. The combined efforts of these trees in
bootstrap aggregation allow for superior classification and regression
predictions compared to classical statistical models [@biau2016random].
This flexibility enables biomedical experts to tackle various tasks,
including cancer survival analysis, disease progression prediction, and
healthcare resource optimization.

One of the most notable applications of RF in healthcare is survival
analysis, particularly in colon cancer research. Studies utilizing SEER
data have compared RF to the Cox proportional hazards model,
highlighting RF’s ability to handle missing data and complex
interactions more effectively [@breiman2001random]. Additionally, RF has
been widely used in clinical decision-making, such as predicting ICU
patient outcomes and identifying those at high risk of sepsis.Another
critical application is diabetes prediction and prevention. RF not only
forecasts diabetes development but also provides personalized
recommendations to healthcare professionals, helping them implement
preventive measures and improve patient outcomes[@khine2022diabetes].

Beyond diagnostics, RF is also instrumental in handling imbalanced
datasets. For instance, in predicting disease susceptibility, random
subsampling techniques within RF have been shown to outperform other
machine learning models such as support vector machines, boosting, and
bagging [@khalilia2011predicting]. Furthermore, RF has been used in
healthcare resource planning, such as forecasting the demand for
essential medications in public health facilities to ensure supply chain
efficiency and prevent shortages [@mbonyinshuti2022demand].

RF is a powerful algorithm, but it also has its challenges.
Hyperparameter tuning is crucial for maximizing predictive accuracy,
with factors such as the number of trees (L), sample size per tree, and
the number of variables considered at each split (mtry) all
significantly influencing model performance
[@probst2019hyperparameters]. While RF often performs well with default
settings, fine-tuning these parameters can enhance both reliability and
speed [@boulesteix2012overview]. However, the major drawback remains
model interpretability, which is critical in medical decision-making.
Researchers have proposed methods such as conditional inference forests
(CIF) to improve reliability while reducing bias in variable selection
[@dai2018using].

Since RF was first introduced to clinical diagnostics, it has been
regarded as one of the most effective tools in medical prediction
models. This study explores its performance compared to traditional
statistical techniques and evaluates whether advancements in
hyperparameter optimization can further enhance its effectiveness. By
synthesizing insights from multiple sources, this analysis provides a
comprehensive understanding of RF’s potential in healthcare analytics
while identifying areas for further refinement.

## Methods

The random forest algorithm generates numerous decision trees using
randomization and then aggregates the output of these trees into one
output. A decision tree is an algorithm that has a ‘tree-like’
structure, consisting of a root node, branches, internal nodes and leaf
nodes. The root node branches out into internal nodes, and depending on
the outcome of each internal node, it ultimately leads to the leaf node;
or the final outcome, or decision. In the formation of a random forest,
a voting method is used for classification and an averaging method for
regression. Randomization is done in two steps. The first uses bootstrap
aggregation or bagging at the data set level, creating new randomized
samples for the model development and testing. Bagging consists of
randomly sampling from the original data set with replacement, ensuring
the sample set is completely random. The data that is not used in the
sampled data set is considered the out-of-bag (OOB) data. The next level
of randomization happens at the decision node level. A certain number of
predictors are chosen, which is often the square root of the number of
predictors in the data set. The algorithm tests all possible thresholds
for all selected variables and chooses the variable-threshold
combination which results in the best split – the split which most
effectively separates cases from controls, for instance
[@rigatti2017random]. This random selection of variables and threshold
testing continues until either “pure” nodes are reached (containing only
cases or controls) or some pre-defined endpoint [@rigatti2017random].

***Hyper parameters Overview***

Table 1 below shows a summary of the different hyperparameters of random
forest and typical default values. Here, n is the number of observations
and p is the number of variables in the dataset.

```{r}
table = data.frame(Hyperparameter = c("mtry",
                                      "Sample size",
                                      "Replacement",
                                      "Node size",
                                      "Number of trees",
                                      "Splitting rule"),
Description = c("Number of drawn candidate variables in each split",
                "Number of observations that are drawn for each tree",
                "Draw observations with or without replacement",
                "Minimum number of observations in a terminal node",
                "Number of trees in a forest",
                "Splitting criteria in the nodes"),
"Typical Default Values" = c("sqrt(p), p/3 for regression",
                           "n",
                           "TRUE (with replacement)",
                           "1 for classification, 5 for regression",
                           "500, 1,000",
                           "Gini impurity, p value, random")
)

knitr::kable(table, 
             caption = "Overview of the different hyperparameters",
             col.names = c("Hyperparameter",
                           "Description",
                           "Typical Default Values"))
```

Table 1. [@probst2019hyperparameters]

Table 1 provides an overview of the hyperparameters available to tune
the decision forest, along with the recommended or default values. The
decision forest algorithm is designed to work well without much tuning.
It’s been found that an increased number of trees provides a better
output, but there’s typically a limit in which there’s no more gain in
accuracy, and only a decrease or slow down in performance with too many
trees. The hyperparameter ‘mtry’ has been found to have the most
influence, where the best value of ‘mtry’ depends on the number of
variables that are related to the outcome [@probst2019hyperparameters].

***Gini Impurity***

The random forest algorithm uses the Gini measure of impurity to select
the split with the lowest impurity at every node
[@khalilia2011predicting]. The gini impurity can range between 0 - 0.5,
with the lower the impurity, the better the split. If a gini impurity is
0, this means it is a ‘pure’ node and does not need to be split further.
The formula for Gini Impurity is below, where p is the probability of
samples belonging to the class i at a specific node.

$$
Gini = 1 -\sum_{i = 1}^{n}{(p_i)^2}
$$

***Random Forest Implementation in the Dataset***

The random forest model will be applied to analyze the dataset
containing multiple clinical and demographic factors. This dataset has
features like Age, Sex, Type of Chest Pain, Resting Blood Pressure
(RestingBP), Cholesterol level, Fasting Blood Sugar (FastingBS),
Electrocardiogram Results when at Rest (RestingECG), Maximum Heart Rate
attained (MaxHR), Angina induced by exercise, Oldpeak, and ST Slope. The
model will be fitted to the data so the presence or lack of heart
disease (HeartDisease) can be predicted. This variable is the target
(0 - No Heart Disease, 1 - Heart Disease).

***Model Training***

In order to train the model, a dataset will first be created by
splitting it into an 70% training and 30% testing set for evaluation.
The random forest will have an ensemble of 100 decision trees
(n_estimators = 100) and the mtry value for each split will be the
square root of the total number of features [@oshiro2012many]. The Gini
impurity metric will be utilized and will ensure that the most
informative features are selected [@khalilia2011predicting]. Other
parameter control methodologies such as grid or randomized search will
be used to optimize the number of trees, maximum depth, and minimum
sample split [@probst2019hyperparameters].

***Model Evaluation and Performance Metrics***

For the model evaluation, the following metrics will be applied:

-   AUC-ROC Score: Evaluates the model's classification capability for
    distinguishing classes (Heart Disease vs. No Heart Disease)
    [@probst2019rfhealth]. The AUC ROC Score is the area under the curve
    of the ROC (receiver-operating characteristic curve) curve. The ROC
    curve graphs the true positive rate over the false positive rate.
    The higher the ROC AUC, the better. $$
    \text{AUC-ROC} = \int_{0}^{1} \text{TPR} \left( \text{FPR}^{-1}(x) \right) \, dx
    $$

-   Precision: Precision is the ratio of the true positive predictions
    to the total number of positive predictions $$
    Precision = \frac{True Positives}{(True Positives + False Positives)}
    $$

-   Recall (Sensitivity): Recall is the ratio of the true positive
    predictions to all the actual positive instances:
    $$\text{Recall} = \frac{TruePositives}{TruePositives + FalseNegatives}$$

-   F1-score: F1 score is the average of precision and recall. $$
    F1 = \frac{2*(Precision*Recall)}{(Precision + Recall)}
    $$

***Advantages/Disadvantages***

The random forests method remains one of the most robust and versatile
methods for solving classification tasks, especially in the healthcare
sector. Their capability to manage high dimensional data, model
intricate relationships, and rank order features makes them particularly
useful in disease prediction and risk factor evaluation
[@breiman2001random]. All of these benefits come with caveats. While
random forests are robust in overfitting and are efficient with missing
values [@khalilia2011predicting], they also demand above-average
computing power, can be inefficient with time on large databases, and
are less clear than logistic regression models [@probst2019rfhealth].
Imposing certain values to parameters improves these shortcomings but
not without a loss of performance and efficiency in specific datasets.
Regardless, random forests are still a good choice in predictive
modeling in medical research and decision support systems
[@biau2016random].

In summary the Random Forest algorithm has been used in this study
because of its compatibility with structured clinical datasets and its
ability to integrate categorical and numerical data without significant
preprocessing [@breiman2001random]. In contrast to logistic regression,
which applies a mode of linearity, Random Forest is able to capture
complex non-linear relationships in healthcare data
[@probst2019rfhealth]. Another advantage of Random Forest is its
provision of feature importance indices, which enhances the model’s
interpretability by medical practitioners concerning risk prediction and
proactive measures’ implementation[@khalilia2011predicting]

## Analysis and Results

### Data Exploration and Visualization

***Data Set Overview***

Data Set: [Heart Failure Prediction
Data](https://www.kaggle.com/datasets/fedesoriano/heart-failure-prediction/data)

This data set is a compilation of five different data sets from around
the world. It contains 11 features: age, sex, chest pain type, resting
blood pressure, cholesterol, fasting blood sugar, resting
electrocardiogram results, max heart rate, exercise-induced angina, old
peak, and slope of peak exercise ST segment. The data set is used to
predict whether the patient has heart disease or not.

-   **Age**: Age of the patient (years)
-   **Sex**: Sex of the patient (M: Male, F: Female)
-   **ChestPainType**: Chest pain type (TA: Typical Angina, ATA:
    Atypical Angina, NAP: Non-Anginal Pain, ASY: Asymptomatic)
-   **RestingBP**: Resting blood pressure (mm Hg)
-   **Cholesterol**: Serum cholesterol (mg/dL)
-   **FastingBS**: Fasting blood sugar (1: if FastingBS \> 120 mg/dL, 0:
    otherwise)
-   **RestingECG**: Resting electrocardiogram results (Normal, ST:
    having ST-T wave abnormality, LVH: showing probable or definite left
    ventricular hypertrophy by Estes' criteria)
-   **MaxHR**: Maximum heart rate achieved (Numeric value between 60 and
    202) 
-   **ExerciseAngina**: Exercise-induced angina (Y: Yes, N: No)
-   **Oldpeak**: Oldpeak = ST (Numeric value measured in depression)
-   **ST_Slope**: The slope of the peak exercise ST segment (Up:
    upsloping, Flat: flat, Down: downsloping)
-   **HeartDisease**: Output class (1: heart disease, 0: Normal)

```{r}
#Loading packages
library(readr)
library(caret)
library(ggplot2)
library(tidyverse)
library(gridExtra)
library(scales)
library(data.table)
library(knitr)
#install.packages("gtsummary")
library(gtsummary)

#read data to dataframe
data <- read.csv('heart.csv')
#head(data,5)
```

***Table 1: Data Structure Overview***

```{r}
# Convert to a data.table
data_dt <- as.data.table(data)

# Create the structure table with Column, Type, and Sample Values
structure_table <- data_dt[, .(Column = names(data_dt), 
                               Type = sapply(data_dt, class), 
                               values = lapply(data_dt, function(x) paste(head(x, 5), collapse = ", ")))]

# display the table 
kable(structure_table, caption = "Data Structure Overview")
```

(Table 1: Data structure overview of Heart Disease dataset)

The data structure overview table is an essential starting point for
working with the heart disease prediction dataset. The table contains
column names, data types, and examples for every feature as a sample
overview of the dataset. All columns within the dataset are associated
to some clinically significant feature which have the potential to be
used for estimating the risk of heart disease.

***Table 2: Summary Statistics***

```{r}
# statistics of the dataset 
tbl_summary(data) 
```

(Table 2: Summary Statistics of Heart Disease dataset)

The dataset comprises of 918 records and 11 features which include both
categorical and numerical variables that help assess heart disease risk.
Key variables indicating the health of patients include Age, Resting
Blood Pressure (RestingBP), Cholesterol, Maximum Heart Rate (MaxHR), and
ST Depression (Oldpeak) among others. It has no missing or duplicate
values. It is also noted from the data that there are more male patients
(79%) than female patients (21%) which may be noteworthy for analysis.
More than half of the patients (54%) however do not experience chest
pain (ASY) which is rather puzzling despite the patient potentially
having heart disease. In addition, the variable depicting the target
i.e. HeartDisease is relatively balanced with 55.3 percent of patients
diagnosed to have heart disease and 44.7 percent of patients with no
heart disease. Also, RestingBP and Cholesterol value of 0 may need some
consideration as they are unrealistic and require correction prior to
analysis.

***Figure 1: Distribution of some Features***

```{r, warning=FALSE, echo=T, message=FALSE}
# The distribution of 'Age' with a histogram - normal distribution
ageplot <- ggplot(data, aes(x = Age)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = "Age Distribution", x = "Age", y = "Count")

# The distribution of 'Heart Disease' with a histogram - no class imbalance
hdplot <- ggplot(data, aes(x = HeartDisease)) +
  geom_bar(fill = "blue", color = "black") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks=c(0,1)) +
  labs(title = "Heart Disease Class Distribution", x = "Heart Disease", y = "Count")

# The distribution of 'Sex' with a histogram - imbalance: ~4x more males than females
splot <- ggplot(data, aes(x = Sex)) +
  geom_bar(fill = "blue", color = "black") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = "Sex Distribution", x = "Sex", y = "Count")

# The distribution of 'Cholesterol' with a histogram - over 150 records with a cholesterol of 0; otherwise normal distribution
cplot <- ggplot(data, aes(x = Cholesterol)) +
  geom_histogram(fill = "blue", color = "black") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = "Cholesterol Distribution", x = "Cholesterol", y = "Count")

grid.arrange(hdplot, splot, ageplot, cplot, ncol = 2, nrow=2)

```

(Figure 1: Pictorical representation of some of distribution/trends of
Heart Disease data set)

Figure 1 outlines some distribution/trends which are relevant in
predicting heart diseases.

-   **Heart Disease Distribution (Top-Left):** The distribution is
    appropriately balanced, minimizing the chances of bias in the model.
-   **Sex Distribution (Top-Right):** The dataset has more male patients
    than female, which might impact predictions.
-   **Age Distribution (Bottom-Left):** Most patients fall within the
    40-70 years age range, which may reduce model accuracy for younger
    individuals.
-   **Cholesterol Distribution (Bottom-Right):** The presence of zero
    values in cholesterol is unrealistic, indicating the need for data
    cleaning.

***Figure 2: Correlation Matrix – Understanding Key Relationships***

```{r, warning=FALSE, echo=T, message=FALSE}

# correlation matrix for numeric features
library(corrplot)
numeric_data <- data %>% select(where(is.numeric))
cor_matrix <- cor(numeric_data)
corrplot(cor_matrix, method = "circle", type = "upper", 
         tl.col = "black", tl.cex = 0.7, addCoef.col = "black")
```

(Figure 2: Relationships of features in dataset with heart disease)

In figure 2, relationships of features in dataset with heart disease.
Among the predictors, Oldpeak (0.40) stands out since higher ST
depression is associated with heart disease risk. Patients who have
heart disease are more likely to have high heart rates, which is
strongly correlated with heart disease( MaxHR (-0.40)). Age (0.28) and
Fasting Blood Sugar (0.27) also emerged as positive correlates,
confirming that older people and people with high fasting blood sugar
levels are at risk. Cholesterol with its weak negative correlation is
also interesting (-0.23) and can be explained through medication or
lifestyle changes.

These insights could assist with feature selection and simultaneously
ensure that major predictors such as Oldpeak, MaxHR, and Age, which are
associated , leading to more reliable and clinically relevant
predictions of heart disease.

### Modeling and Results

In this section, we will begin with performing any necessary cleaning
and preprocessing of the data. We will then use the decision tree
algorithm to demonstrate how a decision tree works, and show the
performance of one tree. The next step will be using the random forest
algorithm, which is a combination of decision trees, to see how it
performs in comparison, ideally providing a more accurate prediction.

***Data Preprocessing and Cleaning***

While there was no null or NA missing values found in the data set, we
did find that there were some RestingBP and Cholesterol values of 0.
There was one row with a RestingBP = 0 and 172 rows with Cholesterol =
0. We decided to drop these rows from the data set, as they were missing
valid data.

```{r}
#| include: false
bp0 <- sum(data$RestingBP == '0')
bp0
cho1 <- sum(data$Cholesterol == '0' & data$HeartDisease == '1')
cho1
cho2 <- sum(data$Cholesterol == '0' & data$HeartDisease == '0')
cho2
```

```{r}
#Remove the bad data
newdata <- data[data$Cholesterol != 0, ]

bp0 <- sum(newdata$RestingBP == '0') #results in 0
cho <- sum(newdata$Cholesterol == '0') #results in 0
```

Our next step is to encode the data. The random forest alogorithm, along
with most machine learning algorithms, functions best with numerical
values. Therefore, we will transform the categorical variables to
numeric. We will use one-hot encoding to transform the categorical
variables into a binary column that indicates the presense (1) or
absence (0) of the category.

***Encoded Data Preview***

```{r}
library(caret)
dmy <- dummyVars(" ~ .", data = newdata)
encoded <- data.frame(predict(dmy, newdata = newdata))
encoded$HeartDisease <- as.factor(encoded$HeartDisease)
kable(encoded[1:3, ])
```

***Splitting the Data*** (70% Train and 30% Test)

We split the data set into training and test subsets. The training
subset will contain 70% of the data, and the test subset will contain
30% of the data.

```{r}
#install.packages("caTools")
library(caTools)
## set seed for reproducibility
set.seed(555)

ind = sample.split(Y = encoded$HeartDisease, SplitRatio = 0.7)

#subsetting into Train data
train = encoded[ind,]

#subsetting into Test data
test = encoded[!ind,]
```

***Model Fitting and Prediction***

**Decision Tree**

We first demonstrate how a single decision tree would look for our data
set. We achieved an accuracy of 81.7% without hyperparameter tuning. The
decision tree can be followed to determine what the predicted end result
would be. For example, if the patient has ST_SlopeUp = 1 and
ChestPainTypeASY = 0; they likely do not have heart disease. If the
patient has ST_SlopeUp = 0, MaxHR \< 151, SexF = 0, then the patient
likely does have heart disease.

```{r}
library(rpart)
library(rpart.plot)
library(caret)
tree <- rpart(HeartDisease ~ ., 
                    data = train, 
                    method = "class",
                    control = rpart.control(minsplit = 10, cp = 0.01))

rpart.plot(tree, box.palette = "auto", nn = TRUE)

predictions <- predict(tree, test, type = "class")
#confusionMatrix(predictions, test$HeartDisease)
```

**Random Forest**

After gaining an understanding of how a single decision tree functions;
we proceed with the bulk of our analysis using the random forest
algorithm. We trained the random forest using 100 trees and graphed the decision tree and evaluation metrics below. The random forest achieved an accuracy of 88.4%, which is higher than the 81.7% obtained from the single decision tree, as expected. The confusion matrix shows that there were 104 true negatives (HeartDisease=0), 94 true positives (HeartDisease=1), 13 false negatives, and 13 false positives. Precision, recall, sensitivity, and F1 scores were all the same.

```{r}
library(randomForest)
rf <- randomForest(HeartDisease ~ .,  
                        data = train,  
                        n_tree=100)
#print(rf)

prediction <- predict(rf, newdata = test)
cm <- confusionMatrix(prediction, test$HeartDisease)

draw_confusion_matrix <- function(cm) {

  layout(matrix(c(1,1,2)))
  par(mar=c(2,2,2,2))
  plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
  title('CONFUSION MATRIX', cex.main=2)

  # create the matrix 
  rect(150, 430, 240, 370, col='#3F97D0')
  text(195, 435, 'HeartDisease=0', cex=1.2)
  rect(250, 430, 340, 370, col='#F7AD50')
  text(295, 435, 'HeartDisease=1', cex=1.2)
  text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
  text(245, 450, 'Actual', cex=1.3, font=2)
  rect(150, 305, 240, 365, col='#F7AD50')
  rect(250, 305, 340, 365, col='#3F97D0')
  text(140, 400, 'HeartDisease=0', cex=1.2, srt=90)
  text(140, 335, 'HeartDisease=1', cex=1.2, srt=90)

  # add in the cm results 
  res <- as.numeric(cm$table)
  text(195, 400, res[1], cex=1.6, font=2, col='white')
  text(195, 335, res[2], cex=1.6, font=2, col='white')
  text(295, 400, res[3], cex=1.6, font=2, col='white')
  text(295, 335, res[4], cex=1.6, font=2, col='white')

  # add in the specifics 
  plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETAILS", xaxt='n', yaxt='n')
  text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
  text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
  text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
  text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
  text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
  text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
  text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
  text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
  text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
  text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)

  # add in the accuracy information 
  text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
  text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
  text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
  text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}  

draw_confusion_matrix(cm)
```
***ROC Curve and AUC***

```{r}
library(pROC)
rf_roc <- roc(as.numeric(test$HeartDisease), as.numeric(prediction))
plot(rf_roc, main = "ROC Curve", col = "blue")
auc(rf_roc)
```

***Feature Importance Plot***

```{r}
varImpPlot(rf, main = "Variable Importance")
```

### Conclusion

-   Summarize your key findings.

-   Discuss the implications of your results.

## References
